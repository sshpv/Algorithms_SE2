# Исследование HyperLogLog

Пухова А.И. 
БПИ 245

## Этап 1. Инфраструктура

### RandomStreamGen
Генерирует поток строк длиной до 30 символов.
Алфавит: прописные/строчные латинские буквы, цифры 0–9, тире `-`.
Для моделирования повторов используется параметр `duplicate_prob`: с этой вероятностью
следующий элемент потока выбирается из уже встреченных элементов.

Разбиение потока на части реализовано как набор размеров префиксов по шагу `step_percent`
(например, 10%: 10, 20, …, 100).

### HashFuncGen
Реализует хеш-функцию `h: U -> [0, 2^32)`:
- FNV-1a 64-bit (быстро и просто для строк);
- финализация SplitMix64 для перемешивания битов;
- берём младшие 32 бита, что соответствует модулю `2^32`.

Такой подход даёт близкую к равномерной картину распределения значений.

---

## Этап 2. Реализация HyperLogLog и оценка точности

### Реализация HLL
Для каждого элемента x вычисляется 32-битный хеш `h(x)`.
Первые `B` бит хеша задают индекс регистра `j` (всего `m = 2^B` регистров).
Оставшиеся `32-B` бит используются для вычисления `rho` — позиции первого `1` (leading zeros + 1).

Регистр обновляется так:
`M[j] = max(M[j], rho(w))`.

Оценка:
`E = alpha_m * m^2 / sum_j 2^{-M[j]}`

Использованы стандартные корректировки:
- linear counting (small range), если много нулевых регистров;
- large range correction для пространства 32-битных хешей.

### Точное значение F0_t
Точное количество уникальных элементов в префиксе потока считаем через `unordered_set`.

### Выбор параметра B
Теоретическая относительная ошибка HLL:
`RSE ≈ 1.04 / sqrt(m)`, где `m=2^B`.
Компромисс: больше B → меньше ошибка, но больше память (O(m)).

По умолчанию выбран `B=12`:
- `m=4096`,
- `RSE ≈ 1.04/64 ≈ 1.6%`,
- память регистров ~ 4096 байт.

---

## Эксперименты
Генерируем `num_streams` потоков (по умолчанию 30), длина `stream_size` (по умолчанию 200000),
шаг `step_percent` (по умолчанию 10%).

Для каждого потока и каждого префикса считаем:
- точное `F0_t`,
- оценку HLL `N_t`.

Все результаты сохраняются в `results.csv`.

---

## Визуализация
Скрипт `scripts/analyze.py` строит:
1) Graph #1: True F0_t vs HLL N_t (для потока stream 0).
2) Graph #2: E[N_t] и область E[N_t] ± sigma.
3) Graph #3: сравнение среднего абсолютного относительного отклонения с теорией:
   линии `1.042/sqrt(m)` и `1.32/sqrt(m)`.

---

## Этап 3. Анализ результатов
Ниже приведён пример одного прогона (данные и графики включены в репозиторий).

**Параметры прогона:**
- `streams=20`, `size=100000`, `step=10%`, `dup=0.25`, `B=12` (то есть `m=4096`).

### 1) Точность и соответствие теории
Теоретическая относительная ошибка (RSE) для HLL:
- \(1.042/\sqrt{m} \approx 0.01628\) (≈ 1.63%)
- \(1.32/\sqrt{m} \approx 0.02063\) (≈ 2.06%) — более грубая верхняя оценка.

По данным `out/aggregated_stats.csv`:
- средняя по t абсолютная относительная ошибка среднего \(|\mathbb{E}(N_t)-F^0_t|/F^0_t\) ≈ **0.36%**
- максимальная по t ≈ **0.62%**

Это заметно **меньше** теоретической величины порядка 1.63%, что ожидаемо: теоретическая RSE описывает типичное СКО оценки, а не обязательно смещение среднего.

### 2) Стабильность (дисперсия)
Оценим относительное стандартное отклонение: \(\sigma_{N_t}/F^0_t\).

По данным `out/aggregated_stats.csv`:
- среднее по t \(\sigma_{N_t}/F^0_t\) ≈ **1.56%**
- максимум по t ≈ **1.93%**

Это находится вблизи ожидаемого уровня **~1.63%** и укладывается в ориентир **2.06%**.

### 3) Константы и их влияние
- Увеличение `B` (то есть числа регистров `m`) должно уменьшать дисперсию примерно как \(1/\sqrt{m}\), но увеличивает память O(m).
- Коррекция small range (linear counting) особенно важна на малых t, когда много нулевых регистров.
- Коррекция large range существенна для приближения к пределам 32-битного пространства, в наших прогонах она почти не влияет.

---
## Структура
- `src/` — C++ реализация RandomStreamGen, HashFuncGen, HyperLogLog и точного счётчика
- `scripts/analyze.py` — анализ и построение графиков
- `REPORT.md` — отчёт по этапам 1–3
- `CMakeLists.txt` — сборка

## Как запустить

### Сборка
```bash
mkdir -p build
cd build
cmake ..
cmake --build . -j
```

### Генерация CSV
```bash
./hll --streams 30 --size 200000 --step 10 --dup 0.20 --B 12 --seed 42 --out results.csv
```
Появится файл results.csv

### Анализ и графики
```bash
python3 -m pip install pandas matplotlib
python3 scripts/analyze.py --csv results.csv --B 12 --outdir out
```
Появится папка out, в которой будут png графики
---

## Этап 4. идеи улучшений
1) Упаковка регистров в 6 бит (т.к. rho <= 32) → экономия памяти.
2) Замена хеша на MurmurHash3 (при наличии) → потенциально меньше корреляций/дисперсии.

В текущем проекте реализована базовая версия HLL; улучшения можно добавить отдельным классом.
